#version 430

// ---------------------------
// THREAD GROUP
// ---------------------------
layout(local_size_x = 16, local_size_y = 16) in;

// ---------------------------
// ACCUMULATION IMAGE (lecture+écriture)
// ---------------------------

layout(rgba32f, binding = 0) coherent uniform image2D imgAccum;

// ---------------------------
// TYPES (identiques à ton code)
// ---------------------------
struct Sphere {
    vec4 centerRadius;

    vec3 diffuse;   float kd;
    vec3 specular;  float ks;
    float shininess;
    float pad1, pad2, pad3;
};

struct Square {
    vec4 a;
    vec4 b;
    vec4 c;
    vec4 d;

    vec3 diffuse;   float kd;
    vec3 specular;  float ks;
    float shininess;
    float pad1, pad2, pad3;
};


struct Light {
    vec4 posIntensity;
    vec4 color;
};

// ---------------------------
// SSBO
// ---------------------------
layout(std430, binding = 1) buffer Spheres { Sphere spheres[]; };
layout(std430, binding = 2) buffer Lights  { Light  lights[];  };
layout(std430, binding = 3) buffer Squares { Square squares[]; };

// ---------------------------
// UNIFORMS
// ---------------------------

layout(location = 0) uniform int u_sphereCount;
layout(location = 1) uniform int u_lightCount;
layout(location = 2) uniform vec3 u_camPos;
layout(location = 3) uniform vec3 u_camFront;
layout(location = 4) uniform vec3 u_camRight;
layout(location = 5) uniform vec3 u_camUp;
layout(location = 6) uniform float u_fovDeg;
layout(location = 7) uniform int u_width;
layout(location = 8) uniform int u_height;
layout(location = 9) uniform int u_squareCount;
layout(location = 10) uniform int u_frameIndex;

// -------
// RNG
// -------
uint hash_u(uint x)
{
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    x *= 0x846ca68bu;
    x ^= x >> 16;
    return x;
}

float randf(inout uint state)
{
    state = hash_u(state);
    return float(state) / 4294967296.0;
}

// -----------------------
// hemisphere sampling
// -----------------------
vec3 randomHemisphere(vec3 N, inout uint seed)
{
    float u = randf(seed);
    float v = randf(seed);

    float phi = 2.0 * 3.14159265358979323846 * u;
    float cosTheta = v;
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));

    vec3 T = normalize(abs(N.x) > 0.1 ? cross(N, vec3(0,1,0)) : cross(N, vec3(1,0,0)));
    vec3 B = cross(N, T);

    return normalize(
        T * (cos(phi) * sinTheta) +
        B * (sin(phi) * sinTheta) +
        N * cosTheta
    );
}

// -------------
// HIT STRUCT
// -------------
struct Hit {
    float t;
    vec3 pos;
    vec3 normal;

    vec3 diffuse;
    float kd;

    vec3 specular;
    float ks;

    float shininess;
};



// ---------------
// INTERSECTIONS
// ---------------
bool intersectSphere(vec3 ro, vec3 rd, vec4 cR, out float t)
{
    vec3 oc = ro - cR.xyz;
    float r = cR.w;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - r*r;
    float disc = b*b - c;
    if (disc < 0.0) return false;

    float sq = sqrt(disc);
    float t1 = -b - sq;
    float t2 = -b + sq;

    t = (t1 > 0.001) ? t1 : ((t2 > 0.001) ? t2 : -1.0);
    return t > 0.0;
}

bool intersectQuad(vec3 ro, vec3 rd, Square sq,
                   out float tHit, out vec3 normalOut, out vec3 diffuse, out vec3 specular, out float kd,out float ks,out float shininess)
{
    vec3 A = sq.a.xyz;
    vec3 B = sq.b.xyz;
    vec3 C = sq.c.xyz;
    vec3 D = sq.d.xyz;

    vec3 N = normalize(cross(B - A, D - A));
    float denom = dot(N, rd);
    if (abs(denom) < 1e-6) return false;

    float t = dot(A - ro, N) / denom;
    if (t <= 0.001) return false;

    vec3 P = ro + rd * t;

    vec3 c1 = cross(B - A, P - A);
    vec3 c2 = cross(C - B, P - B);
    vec3 c3 = cross(A - C, P - C);

    if (dot(c1,N) >= 0.0 && dot(c2,N) >= 0.0 && dot(c3,N) >= 0.0) {
        tHit = t; normalOut = N; diffuse = sq.diffuse;
        specular=sq.specular;
        kd=sq.kd;
        ks=sq.ks;
        shininess=sq.shininess;
        return true;
    }

    vec3 c4 = cross(C - A, P - A);
    vec3 c5 = cross(D - C, P - C);
    vec3 c6 = cross(A - D, P - D);

    if (dot(c4,N) >= 0.0 && dot(c5,N) >= 0.0 && dot(c6,N) >= 0.0) {
        tHit = t;
        normalOut = N;
        diffuse = sq.diffuse;
        specular=sq.specular;
        kd=sq.kd;
        ks=sq.ks;
        shininess=sq.shininess;

        return true;
    }

    return false;
}

// ---------
// TRACE
// ---------
bool trace(vec3 ro, vec3 rd, out Hit hit)
{
    hit.t = 1e30;
    bool found = false;

    for (int i = 0; i < u_sphereCount; ++i)
    {
        float t;
        if (intersectSphere(ro, rd, spheres[i].centerRadius, t)) {
            if (t < hit.t) {
                hit.t = t;
                hit.pos = ro + rd * t;
                hit.normal = normalize(hit.pos - spheres[i].centerRadius.xyz);

                hit.diffuse = spheres[i].diffuse;
                hit.kd = spheres[i].kd;
                hit.specular = spheres[i].specular;
                hit.ks = spheres[i].ks;
                hit.shininess = spheres[i].shininess;

                found = true;
            }
        }

    }

    for (int i = 0; i < u_squareCount; ++i)
    {
        float t; vec3 n; vec3 diffuse;
        float kd; float ks; float shininess;
        vec3 specular;
        if (intersectQuad(ro, rd, squares[i], t, n, diffuse,specular,kd,ks,shininess))
        {
            if (t < hit.t) {
                hit.t = t;
                hit.pos = ro + rd * t;
                hit.normal = n;
                hit.diffuse = diffuse;
                hit.specular=specular;
                hit.kd=kd;
                hit.ks=ks;
                hit.shininess=shininess;
                found = true;
            }
        }
    }

    return found;
}

// --------------------
// MAIN PATH TRACER
// --------------------
void main()
{
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
    if (px.x >= u_width || px.y >= u_height) return;

    uint seed = uint(px.x) + uint(px.y) * 1664525u + uint(u_frameIndex) * 1013904223u;
    seed = hash_u(seed);

    float jx = randf(seed);
    float jy = randf(seed);
    vec2 uv = ((vec2(px) + vec2(jx, jy)) / vec2(u_width, u_height)) * 2.0 - 1.0;

    float fov = radians(u_fovDeg);
    float aspect = float(u_width) / float(u_height);
    float sx = uv.x * aspect * tan(fov*0.5);
    float sy = uv.y * tan(fov*0.5);

    vec3 ro = u_camPos;
    vec3 rd = normalize(u_camRight*sx + u_camUp*sy + u_camFront);

    vec3 throughput = vec3(1.0);
    vec3 radiance = vec3(0.0);

    const int MAX_BOUNCES = 5;
    for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce)
    {
        Hit h;
        if (!trace(ro, rd, h)) {
            radiance += throughput * vec3(0.2, 0.3, 0.7);
            break;
        }

        vec3 V = normalize(-rd);
        vec3 directLight = h.diffuse * 0.1; // ambient = diffuse * 0.1

        for (int li = 0; li < u_lightCount; li++)
        {
            vec3 Lpos = lights[li].posIntensity.xyz;
            float intensity = lights[li].posIntensity.w;
            vec3 lightColor = lights[li].color.rgb;

            vec3 L = normalize(Lpos - h.pos);

            // ombres
            Hit block;
            if (trace(h.pos + h.normal * 0.001, L, block)) {
                float distLight = length(Lpos - h.pos);
                if (block.t < distLight)
                    continue;
            }

            // Diffuse : Lambert * kd
            float diff = max(dot(h.normal, L), 0.0);
            vec3 diffuseTerm = h.kd * h.diffuse * diff;

            // Speculaire : Phong * ks
            vec3 R = reflect(-L, h.normal);
            float spec = pow(max(dot(R, V), 0.0), h.shininess);
            vec3 specTerm = h.ks * h.specular * spec;

            // lumière
            vec3 contribution = (diffuseTerm + specTerm) * lightColor * intensity;

            directLight += contribution;
        }

        radiance += throughput * directLight;
        throughput *= h.diffuse;

        if (bounce > 2) {
            float p = clamp(max(max(throughput.r, throughput.g), throughput.b), 0.01, 0.99);
            if (randf(seed) > p) break;
            throughput /= p;
        }

        ro = h.pos + h.normal * 1e-4;
        rd = randomHemisphere(h.normal, seed);
    }
    vec4 old = imageLoad(imgAccum, px);
    float frameF = float(max(u_frameIndex, 0));

    vec3 blended = (old.rgb * frameF + radiance) / (frameF + 1.0);

    imageStore(imgAccum, px, vec4(blended, 1.0));
}
