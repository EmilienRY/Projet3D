#version 430

// compute workgroup
layout(local_size_x = 16, local_size_y = 16) in;

// output image
layout(rgba32f, binding = 0) writeonly uniform image2D imgOutput;

// -------------------------
// types
// -------------------------
struct Sphere {
    vec4 centerRadius; // xyz = center, w = radius
    vec4 color;        // rgb = color, a = unused
};

struct Square {
    vec4 a;
    vec4 b;
    vec4 c;
    vec4 d;
    vec4 color;
};


struct Light {
    vec4 posIntensity; // xyz = position, w = intensity
    vec4 color;        // rgb = color, a = unused
};

// -------------------------
// SSBOs
// -------------------------
layout(std430, binding = 1) buffer Spheres {
    Sphere spheres[];
};

layout(std430, binding = 2) buffer Lights {
    Light lights[];
};

layout(std430, binding = 3) buffer Squares {
    Square squares[];
};


// -------------------------
// uniforms
// -------------------------
layout(location = 0) uniform int u_sphereCount;
layout(location = 1) uniform int u_lightCount;
layout(location = 2) uniform vec3 u_camPos;
layout(location = 3) uniform vec3 u_camFront;
layout(location = 4) uniform vec3 u_camRight;
layout(location = 5) uniform vec3 u_camUp;
layout(location = 6) uniform float u_fovDeg;
layout(location = 7) uniform int u_width;
layout(location = 8) uniform int u_height;
layout(location = 9) uniform int u_squareCount;


// -------------------------
// helper structures / functions
// -------------------------
struct Hit {
    float t;
    vec3 pos;
    vec3 normal;
    vec3 color;
};

bool intersectSphere(vec3 ro, vec3 rd, vec4 cR, out float t)
{
    vec3 oc = ro - cR.xyz;
    float r = cR.w;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - r*r;
    float disc = b*b - c;
    if (disc < 0.0) return false;

    float sq = sqrt(disc);
    float t1 = -b - sq;
    float t2 = -b + sq;

    // return nearest positive
    t = (t1 > 0.001) ? t1 : ((t2 > 0.001) ? t2 : -1.0);
    return t > 0.0;
}

bool intersectPlaneY0(vec3 ro, vec3 rd, out float t, out vec3 normal)
{
    // plane y= -0.5 (change si nÃ©cessaire) -> here plane at y=0
    if (abs(rd.y) < 1e-6) return false;
    t = -ro.y / rd.y;
    if (t <= 0.001) return false;
    normal = vec3(0.0, 1.0, 0.0);
    return true;
}


bool intersectQuad(vec3 ro, vec3 rd, Square sq,
                   out float tHit, out vec3 normalOut, out vec3 colOut)
{
    vec3 A = sq.a.xyz;
    vec3 B = sq.b.xyz;
    vec3 C = sq.c.xyz;
    vec3 D = sq.d.xyz;

    // compute normal
    vec3 N = normalize(cross(B - A, D - A));
    float denom = dot(N, rd);

    if (abs(denom) < 1e-6)
        return false; // ray parallel

    float t = dot(A - ro, N) / denom;
    if (t <= 0.001)
        return false;

    vec3 P = ro + rd * t;

    // test inside ABC
    vec3 c1 = cross(B - A, P - A);
    vec3 c2 = cross(C - B, P - B);
    vec3 c3 = cross(A - C, P - C);
    bool insideABC =
        (dot(c1, N) >= 0.0 &&
         dot(c2, N) >= 0.0 &&
         dot(c3, N) >= 0.0);

    if (insideABC) {
        tHit = t;
        normalOut = N;
        colOut = sq.color.rgb;
        return true;
    }

    // test inside ACD
    vec3 c4 = cross(C - A, P - A);
    vec3 c5 = cross(D - C, P - C);
    vec3 c6 = cross(A - D, P - D);
    bool insideACD =
        (dot(c4, N) >= 0.0 &&
         dot(c5, N) >= 0.0 &&
         dot(c6, N) >= 0.0);

    if (insideACD) {
        tHit = t;
        normalOut = N;
        colOut = sq.color.rgb;
        return true;
    }

    return false;
}

// -------------------------
// main
// -------------------------
void main()
{
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
    if (px.x >= u_width || px.y >= u_height) return;

    vec2 uv = (vec2(px) + vec2(0.5)) / vec2(u_width, u_height) * 2.0 - 1.0;

    float fov = radians(u_fovDeg);
    float aspect = float(u_width) / float(u_height);
    float tanHalf = tan(fov * 0.5);

    float sx = uv.x * aspect * tanHalf;
    float sy = uv.y * tanHalf;

    vec3 rd = normalize(u_camRight * sx + u_camUp * sy + u_camFront);
    vec3 ro = u_camPos;

    Hit hit;
    hit.t = 1e30;
    bool hitSomething = false;

    // spheres
    for (int i = 0; i < u_sphereCount; ++i) {
        float t;
        if (intersectSphere(ro, rd, spheres[i].centerRadius, t)) {
            if (t > 0.0 && t < hit.t) {
                hit.t = t;
                hit.pos = ro + rd * t;
                hit.normal = normalize(hit.pos - spheres[i].centerRadius.xyz);
                hit.color = spheres[i].color.xyz;
                hitSomething = true;
            }
        }
    }

    for (int i = 0; i < u_squareCount; i++) {
        float tq;
        vec3 nq;
        vec3 cq;

        if (intersectQuad(ro, rd, squares[i], tq, nq, cq)) {
            if (tq < hit.t) {
                hit.t = tq;
                hit.pos = ro + rd * tq;
                hit.normal = nq;
                hit.color = cq;
                hitSomething = true;
            }
        }
    }

    vec3 outCol = vec3(0.2, 0.3, 0.5); // background

    if (hitSomething) {
        // simple lambertian with all lights (no shadows)
        outCol = vec3(0.0);
        for (int i = 0; i < u_lightCount; ++i) {
            vec3 L = normalize(lights[i].posIntensity.xyz - hit.pos);
            float ndl = max(dot(hit.normal, L), 0.0);
            float intensity = lights[i].posIntensity.w;
            vec3 lightColor = lights[i].color.xyz;
            outCol += hit.color * lightColor * ndl * intensity;
        }
        // small ambient
        outCol += hit.color * 0.05;
    }

    imageStore(imgOutput, px, vec4(outCol, 1.0));
}
